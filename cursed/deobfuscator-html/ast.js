const fs = require('fs');
var esprima = require('esprima-next');
var escodegen = require('escodegen');
const { exit, argv } = require('process');

const { ast_decryptFuncs, ast_replaceIdType } = require('./vars/ast_vars');
const { ast_decryptType, ast_decryptor } = require('./ast/decrypt/decryptor');
const { ast_staticIndexes } = require('./ast/indexers/funcs');
const { defineDynamicIndexer } = require('./ast/indexers/dynamic/dynamic_ind');
const { valueToNode, getValueArg, evalBinaryExpression } = require('./ast_utils');
const { initExpression, applyToNodePointer, getValueExpr } = require('./ast/expressions/expr_translate');
const { handleVarProxy, getTrueName, handleAssignementProxy } = require('./ast/proxy/proxy');
const { traverse } = require('./ast_tree');

// ######### Args #########

if (argv.length <= 2) {
    console.error("You should put the path of index.js");
    exit(1);
}

let output = true;
let printconsole = false;

for (const arg of argv) {
    if (arg[0] != '-')
        continue;
    switch (arg) {
        case '-no': // no output
            output = false;
            break;
        case '-p': // print
            printconsole = true;
            break;
    }
}

/// ######### Main #########

const rawCode = fs.readFileSync(argv[2], 'utf8');
const lines = rawCode.split('\n');

// Remove the first and last lines
// since it's embedded in <script> node, it's not pure javascript for esprima...
lines.shift();
lines.pop();

const fCode = lines.join('\n');
var code = esprima.parseScript(fCode, { range: true });

// Traverse the AST and find function declarations and replace them by their output
function traverseCallback(node, scope) {
    if (node.type === 'Identifier') {
        if (!ast_replaceIdType.includes(node.parent.type)
            && (node.parent.type !== 'MemberExpression'
                || !(ast_replaceIdType.includes(node.parent.parent.type)
                    || node.parent.parent.type === 'CallExpression'
                ) || node.parent.property !== node)
            )
            return node;
        const evalValue = scope.getElementFromScope(node.name);
        if (typeof(evalValue) !== 'string' || evalValue.substring(0, 3) === 'pr_') // proxy functions call shouldn't  !
            return node;
        return valueToNode(node, evalValue)
    } else if (node.type === 'CallExpression') {
        if (!node.callee)
            return node;

        if (node.callee.type === 'MemberExpression') {
            for (const func of ast_decryptFuncs) {
                if (func.name === node.callee.object.name) {
                    return ast_decryptor(node, func.decryptfunc, ast_decryptType.MemberExpression, scope);
                }
            }
        } else { // RegularCall
            if (!node.callee.name)
                return node;
            if (node.callee.type !== 'Identifier') // value is replaced
                return node;

            const name = getTrueName(node.callee.name, scope); // get proxy names
            for (const func of ast_staticIndexes) { // 623s27, etc...
                if (func.name === name) {
                    return func.func(node, scope);
                }
            }
            for (const func of ast_decryptFuncs) {
                if (func.name === name) {
                    return ast_decryptor(node, func.decryptfunc, ast_decryptType.RegularCall, scope);
                }
            }
            const func = scope.getElementFromScope(name) // get dynamic indexes functions (oth1jj, etc...)
            if (func != null && typeof(func) === 'function') { // due to missing var assignements, we might not get a function, so skip it until then
                if (!node.arguments[0])
                    return node;
                // const scopedFunc = scope.getElementFromScope(func)
                const arg = getValueArg(node.arguments[0])
                if (arg == null)
                    return node;
                return valueToNode(node, func(arg));
            }
        }
    } else if (node.type === 'VariableDeclaration') { // here we change definitons of scoped functions
        for (const decl of node.declarations) {
            if (!decl.init)
                continue;
            if (decl.init.type === 'Identifier' && handleVarProxy(decl, scope)) // if it's a proxy, continue
                continue;
            if (decl.init.callee && decl.init.callee.body) { // probably a dynamic indexer function
                try {
                    const value = decl.init.callee.body.body[0].argument.body.body[0].argument;
                    defineDynamicIndexer(decl.id.name, value, scope, node);
                } catch(e) {
                    console.error(decl.id.name)
                }
            } else if (decl.init.type === 'Literal') {
                if (handleAssignementProxy(decl.id, scope))
                    continue;
                const value = evalBinaryExpression(decl.init);
                scope.setElementInScope(decl.id.name, value, node);
            }
        }
    } else if (node.type === 'AssignmentExpression') {
        if (node.left.type === 'MemberExpression') {
            const badIndex = getValueExpr(node.left);
            if (badIndex == null)
                return node;
            let array = scope.getElementFromScope(node.left.object.name);
            if (!Array.isArray(array))
                return node;
            array[badIndex] = node.right;
            return node;
        }

        if (!(node.left.type === 'Identifier' && (node.right.type === 'Literal' || node.right.type === 'UnaryExpression'))) {
            return node;
        }
        if (handleAssignementProxy(node.left, scope))
            return node;

        const value = getValueArg(node.right);
        if (value == null)
            return node;
        scope.setElementInScope(node.left.name, value, node.left);
    } else if (node.type === 'MemberExpression') {
        // !! variadict deobfuscation => very aggressive replacement
        let array = scope.getElementFromScope(node.object.name);
        if (array == null || !Array.isArray(array))
            return node;

        // This member expression is an assignment, don't replace it
        if (node.parent.type === 'AssignmentExpression' && node.parent.left === node) {
            return node;
        }

        const value = evalBinaryExpression(node.property);
        if (value == null || typeof(value) !== 'number') // due to var assignment errors, value might not be a number
            return node;
        let correctNode = array[value];
        if (typeof(correctNode) === 'undefined')
            return node;
        const oldParent = node.parent;
        applyToNodePointer(correctNode, node);
        node.parent = oldParent;
        // !! ////////////////////////////
    } else if (node.type === 'BinaryExpression') {
        const value = evalBinaryExpression(node);
        if (value == null)
            return node;
        if (typeof value === 'number' && isNaN(value)) // due to var assignment errors, results can be a number type but is in fact a NaN (which escodegen hates).
            return node;
        return valueToNode(node, value);
    }
    return node;
}

function traversePreCallback(node, scope) {
    if (node.type === 'ExpressionStatement') {
        if (node.expression.type === 'CallExpression')
            return node;
        return initExpression(node, scope); // init array for variadic obfuscation in scope
    } else if (node.type === 'VariableDeclaration') {
        // we are defining here since in case the function is declared during the declarations, we need to
        // retraverse the ast to apply, so before, we just check if any function declartions are here before.
        // However, this method is bad if you redeclare the same function after a few variables but with a diffrent index, we have to make everything in recursion, never in flat loops (like this)
        // this actual workaround is easy to make, but for future type of ASTs, we should consider the text above.
        for (const decl of node.declarations) {
            if (!decl.init)
                continue;
            if (decl.init.callee && decl.init.callee.body) { // probably a dynamic indexer function
                try {
                    const value = decl.init.callee.body.body[0].argument.body.body[0].argument;
                    defineDynamicIndexer(decl.id.name, value, scope, node);
                } catch(e) {
                    console.error(decl.id.name)
                }
            }
        }
    }
    return node;
}

traverse(code, traverseCallback, traversePreCallback);

if (output) {
    const res = escodegen.generate(code);
    if (printconsole) {
        console.log(res);
    } else {
        fs.writeFile("./output/index_deob.html.js", res, function(err) {
            if(err) {
                return console.log(err);
            }
            console.log("The file was saved! : ./output/index_deob.html.js");
        });
    }
}
