const fs = require('fs');
var esprima = require('esprima-next');
var escodegen = require('escodegen');
const { exit, argv } = require('process');

const { ast_decryptFuncs } = require('./vars/ast_vars');
const { ast_decryptType, ast_decryptor } = require('./ast/decrypt/decryptor');
const { Scope } = require('./ast/scope/scope');
const { ast_staticIndexes } = require('./ast/indexers/funcs');
const { defineDynamicIndexer } = require('./ast/indexers/dynamic/dynamic_ind');
const { valueToNode, getValueArg } = require('./ast_utils');
const { translateExpression } = require('./ast/expressions/expr_translate');
const { handleVarProxy, getTrueName, handleAssignementProxy } = require('./ast/proxy/proxy');

// ######### Args #########

if (argv.length <= 2) {
    console.error("You should put the path of index.js");
    exit(1);
}

let output = true;
let printconsole = false;

for (const arg of argv) {
    if (arg[0] != '-')
        continue;
    switch (arg) {
        case '-no': // no output
            output = false;
            break;
        case '-p': // print
            printconsole = true;
            break;
    }
}

/// ######### Main #########

const fCode = fs.readFileSync(argv[2], 'utf8');
var code = esprima.parseScript(fCode, { range: true });

var scope = new Scope();

// Function to recursively traverse the AST
function traverse(node, callback) {
    const scopeType = scope.isNodeBlock(node)
    if (scopeType) {
        scope.inc(scopeType);
    }

    // Go inside node content

    for (let key in node) {
        if (key === 'parent')
            continue;
        if (node.hasOwnProperty(key)) {
            let child = node[key];
            if (child && typeof child === 'object') {
                if (Array.isArray(child)) {
                    child.forEach(function(arrchild) {
                        arrchild.parent = node;
                        traverse(arrchild, callback);
                    });
                } else {
                    child.parent = node;
                    traverse(child, callback);
                }
            }
        }
    }

    // clean scope functions :
    // even if the list is zero, it shouldn't crash since it must be defined in the scope
    if (scopeType) {
        scope.dec(scopeType);
    }

    node = callback(node); // Evaluate children before
}

// Traverse the AST and find function declarations and replace them by their output
function traverseCallback(node) {
    if (node.type === 'Identifier') {
        if (node.parent.type !== 'BinaryExpression'
            && node.parent.type !== 'Property'
            && node.parent.type !== 'ArrayExpression')
            return node;
        const evalValue = scope.getElementFromScope(node.name);
        if (typeof(evalValue) !== 'string' || evalValue.substring(0, 3) === 'pr_') // proxy functions call shouldn't  !
            return node;
        return valueToNode(node, evalValue)
    } else if (node.type === 'CallExpression') {
        if (!node.callee)
            return node;

        if (node.callee.type === 'MemberExpression') {
            for (const func of ast_decryptFuncs) {
                if (func.name === node.callee.object.name) {
                    return ast_decryptor(node, func.decryptfunc, ast_decryptType.MemberExpression, scope);
                }
            }
        } else { // RegularCall
            if (!node.callee.name)
                return node;
            if (node.callee.type !== 'Identifier') // value is replaced
                return node;

            const name = getTrueName(node.callee.name, scope); // get proxy names
            for (const func of ast_staticIndexes) { // 623s27, etc...
                if (func.name === name) {
                    return func.func(node);
                }
            }
            for (const func of ast_decryptFuncs) {
                if (func.name === name) {
                    return ast_decryptor(node, func.decryptfunc, ast_decryptType.RegularCall, scope);
                }
            }
            const func = scope.getElementFromScope(name) // get dynamic indexes functions (oth1jj, etc...)
            if (func != null) {  
                if (!node.arguments[0])
                    return node;
                // const scopedFunc = scope.getElementFromScope(func)
                const arg = getValueArg(node.arguments[0])
                if (arg == null)
                    return node;
                return valueToNode(node, func(arg));
            }
        }
    } else if (node.type === 'VariableDeclaration') { // here we change definitons of scoped functions
        for (const decl of node.declarations) {
            if (!decl.init)
                continue;
            if (decl.init.type === 'Identifier' && handleVarProxy(decl, scope)) // if it's a proxy, continue
                continue;
            if (decl.init.callee && decl.init.callee.body) { // probably a dynamic indexer function
                try {
                    const value = decl.init.callee.body.body[0].argument.body.body[0].argument;
                    defineDynamicIndexer(decl.id.name, value, scope, node);
                } catch(e) {
                    console.error(decl.id.name)
                }
            }
        }
    } else if (node.type === 'AssignmentExpression') {
        if (!(node.left.type === 'Identifier' && (node.right.type === 'Literal' || node.right.type === 'UnaryExpression'))) {
            return node;
        }
        if (handleAssignementProxy(node.left, scope))
            return node;

        const value = getValueArg(node.right);
        if (value == null || (typeof(value) !== "string" && isNaN(value)) ) // TODO : isnan temp => array based obfuscation is not completed...
            return node;
        scope.setElementInScope(node.left.name, value, node.left);
    } else if (node.type === 'ExpressionStatement') {
        if (node.expression.type === 'CallExpression')
            return node;
        // console.log(escodegen.generate(node));
        translateExpression(node, scope);
    }
    return node;
}

traverse(code, traverseCallback);

if (output) {
    const res = escodegen.generate(code);
    if (printconsole) {
        console.log(res);
    } else {
        fs.writeFile("./output/index_deob.js", res, function(err) {
            if(err) {
                return console.log(err);
            }
            console.log("The file was saved! : ./output/index_deob.js");
        });
    }
}
