const fs = require('fs');
var esprima = require('esprima-next');
var escodegen = require('escodegen');
const { exit, argv } = require('process');

const { ast_decryptFuncs } = require('./vars/ast_vars');
const { ast_decryptType, ast_decryptor } = require('./ast/decrypt/decryptor');
const { ast_staticIndexes } = require('./ast/indexers/funcs');
const { defineDynamicIndexer } = require('./ast/indexers/dynamic/dynamic_ind');
const { valueToNode, getValueArg, evalBinaryExpression } = require('./ast_utils');
const { initExpression, applyToNodePointer, getValueExpr } = require('./ast/expressions/expr_translate');
const { handleVarProxy, getTrueName, handleAssignementProxy } = require('./ast/proxy/proxy');
const { traverse } = require('./ast_tree');

// ######### Args #########

if (argv.length <= 2) {
    console.error("You should put the path of index.js");
    exit(1);
}

let output = true;
let printconsole = false;

for (const arg of argv) {
    if (arg[0] != '-')
        continue;
    switch (arg) {
        case '-no': // no output
            output = false;
            break;
        case '-p': // print
            printconsole = true;
            break;
    }
}

/// ######### Main #########

const fCode = fs.readFileSync(argv[2], 'utf8');
var code = esprima.parseScript(fCode, { range: true });

// Traverse the AST and find function declarations and replace them by their output
function traverseCallback(node, scope) {
    if (node.type === 'Identifier') {
        if (node.parent.type !== 'BinaryExpression'
            && node.parent.type !== 'Property'
            && node.parent.type !== 'ArrayExpression')
            return node;
        const evalValue = scope.getElementFromScope(node.name);
        if (typeof(evalValue) !== 'string' || evalValue.substring(0, 3) === 'pr_') // proxy functions call shouldn't  !
            return node;
        return valueToNode(node, evalValue)
    } else if (node.type === 'CallExpression') {
        if (!node.callee)
            return node;

        if (node.callee.type === 'MemberExpression') {
            for (const func of ast_decryptFuncs) {
                if (func.name === node.callee.object.name) {
                    return ast_decryptor(node, func.decryptfunc, ast_decryptType.MemberExpression, scope);
                }
            }
        } else { // RegularCall
            if (!node.callee.name)
                return node;
            if (node.callee.type !== 'Identifier') // value is replaced
                return node;

            const name = getTrueName(node.callee.name, scope); // get proxy names
            for (const func of ast_staticIndexes) { // 623s27, etc...
                if (func.name === name) {
                    return func.func(node);
                }
            }
            for (const func of ast_decryptFuncs) {
                if (func.name === name) {
                    return ast_decryptor(node, func.decryptfunc, ast_decryptType.RegularCall, scope);
                }
            }
            const func = scope.getElementFromScope(name) // get dynamic indexes functions (oth1jj, etc...)
            if (func != null) {
                if (!node.arguments[0])
                    return node;
                // const scopedFunc = scope.getElementFromScope(func)
                const arg = getValueArg(node.arguments[0])
                if (arg == null)
                    return node;
                return valueToNode(node, func(arg));
            }
        }
    } else if (node.type === 'VariableDeclaration') { // here we change definitons of scoped functions
        for (const decl of node.declarations) {
            if (!decl.init)
                continue;
            if (decl.init.type === 'Identifier' && handleVarProxy(decl, scope)) // if it's a proxy, continue
                continue;
            if (decl.init.callee && decl.init.callee.body) { // probably a dynamic indexer function
                try {
                    const value = decl.init.callee.body.body[0].argument.body.body[0].argument;
                    defineDynamicIndexer(decl.id.name, value, scope, node);
                } catch(e) {
                    console.error(decl.id.name)
                }
            }
        }
    } else if (node.type === 'AssignmentExpression') {
        if (node.left.type === 'MemberExpression') {
            const badIndex = getValueExpr(node.left);
            if (badIndex == null)
                return node;
            let array = scope.getElementFromScope(node.left.object.name);
            if (!Array.isArray(array))
                return node;
            array[badIndex] = node.right;
        }

        if (!(node.left.type === 'Identifier' && (node.right.type === 'Literal' || node.right.type === 'UnaryExpression'))) {
            return node;
        }
        if (handleAssignementProxy(node.left, scope))
            return node;

        const value = getValueArg(node.right);
        if (value == null) // DONE : TODO : isnan temp => array based obfuscation is not completed...
            return node;
        scope.setElementInScope(node.left.name, value, node.left);
    } else if (node.type === 'MemberExpression') {
        // variadict deobfuscation
        let array = scope.getElementFromScope(node.object.name);
        if (array == null || !Array.isArray(array))
            return node;

        // This member expression is an assignment, don't replace it
        if (node.parent.type === 'AssignmentExpression' && node.parent.left === node) {
            return node;
        }

        const value = evalBinaryExpression(node.property);
        if (value == NaN)
            return node;
        if (value == null || typeof(value) === 'string')
            return node;
        let correctNode = array[value]
        if (typeof(correctNode) === 'undefined')
            return node;
        const oldParent = node.parent;
        applyToNodePointer(correctNode, node);
        node.parent = oldParent;
        //////////////////////////////
    } else if (node.type === 'BinaryExpression') {
        const value = evalBinaryExpression(node);
        if (value == null)
            return node;
        if (typeof value === 'number' && isNaN(value))
            return node;
        // console.log(escodegen.generate(node))
        return valueToNode(node, value);
    }
    return node;
}

function traversePreCallback(node, scope) {
    if (node.type === 'ExpressionStatement') {
        if (node.expression.type === 'CallExpression')
            return node;
        // console.log(escodegen.generate(node));
        return initExpression(node, scope);
    }
    return node;
}

traverse(code, traverseCallback, traversePreCallback);

if (output) {
    const res = escodegen.generate(code);
    if (printconsole) {
        console.log(res);
    } else {
        fs.writeFile("./output/index_deob.js", res, function(err) {
            if(err) {
                return console.log(err);
            }
            console.log("The file was saved! : ./output/index_deob.js");
        });
    }
}
