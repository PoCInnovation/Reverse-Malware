const { getValueArg, evalBinaryExpression, valueToNode } = require("../../ast_utils");
const { traverse } = require("../../ast_tree");

function getValueExpr(node) {
    if (node.type === 'MemberExpression') {
        return evalBinaryExpression(node.property);
    } else {
        return evalBinaryExpression(node);
    }
}

// typeof (bbystealsurheartwithlovebrunxkd$sbzfdo = 's.sqli', bbystealsurheartwithlovebrunxkd$oth1jj = 'cookie', bbystealsurheartwithlovebrunxkd$js15qs = 'sqlite', bbystealsurheartwithlovebrunxkd$te6clf = 'story.', bbystealsurheartwithlovebrunxkd$ige25 = 'formhi', bbystealsurheartwithlovebrunxkd$orvr1h = '.json', bbystealsurheartwithlovebrunxkd$sl809 = 'logins', bbystealsurheartwithlovebrunxkd$thmuis = 'Cookie', bbystealsurheartwithlovebrunxkd$1t5ts = 'Web Da', bbystealsurheartwithlovebrunxkd$g00k96 = 'Data', bbystealsurheartwithlovebrunxkd$dlyiu9 = 'Login ');
function initExpression(node, scope) {
    if (!node.expression.argument)
        return node;

    var array = [];
    const firstElement = node.expression.argument.expressions[0];
    // console.log(escodegen.generate(node))
    if (firstElement && firstElement.type === 'AssignmentExpression' && firstElement.left.property && firstElement.left.property.name === 'length') {
        scope.setElementInScope(firstElement.left.object.name, array, node);
    }
    return node;
}

function applyToNodePointer(source, destination) {
    // Clear (remove) all existing keys from the destination object
    for (const key in destination) {
        if (destination.hasOwnProperty(key)) {
            delete destination[key];
        }
    }

    // Copy keys from the source object to the destination object
    for (const key in source) {
        if (source.hasOwnProperty(key)) {
            destination[key] = source[key];
        }
    }
}

function cb_replaceArrayExp(node, array, name) {
    if (node.type === 'MemberExpression' && node.object.name === name && node.parent.type !== 'AssignmentExpression') {
        // console.log(escodegen.generate(node))
        // console.error(escodegen.generate(node.parent))
        const value = evalBinaryExpression(node.property);
        if (value == null)
            return node;
        let correctNode = array[value]
        if (typeof(correctNode) === 'undefined')
            return node;
        const oldParent = node.parent;
        applyToNodePointer(correctNode, node);
        node.parent = oldParent;
    }
    return node;
}

function cb_finalEvalBinaryExpr(node) {
    if (node.type === 'BinaryExpression') {
        const value = evalBinaryExpression(node);
        if (value == null)
            return node;
        return valueToNode(node, value);
    }
    return node;
}

module.exports = { initExpression, applyToNodePointer, getValueExpr }
