const { getValueArg, evalBinaryExpression } = require("../../ast_utils");
const { traverse } = require("../../ast_tree");

// temp
var escodegen = require('escodegen');


function getValueExpr(node) {
    if (node.type === 'MemberExpression') {
        return evalBinaryExpression(node.property);
    } else {
        return evalBinaryExpression(node);
    }
}

// typeof (bbystealsurheartwithlovebrunxkd$sbzfdo = 's.sqli', bbystealsurheartwithlovebrunxkd$oth1jj = 'cookie', bbystealsurheartwithlovebrunxkd$js15qs = 'sqlite', bbystealsurheartwithlovebrunxkd$te6clf = 'story.', bbystealsurheartwithlovebrunxkd$ige25 = 'formhi', bbystealsurheartwithlovebrunxkd$orvr1h = '.json', bbystealsurheartwithlovebrunxkd$sl809 = 'logins', bbystealsurheartwithlovebrunxkd$thmuis = 'Cookie', bbystealsurheartwithlovebrunxkd$1t5ts = 'Web Da', bbystealsurheartwithlovebrunxkd$g00k96 = 'Data', bbystealsurheartwithlovebrunxkd$dlyiu9 = 'Login ');
function translateExpression(node, scope) {
    if (!node.expression.argument)
        return node;
    var array = [];
    let expressions = node.expression.argument.expressions;
    const firstElement = expressions[0];
    // console.log(escodegen.generate(node))
    if (firstElement && firstElement.type === 'AssignmentExpression' && firstElement.left.property && firstElement.left.property.name === 'length') {
        scope.setElementInScope(firstElement.left.object.name, array, node);
    }
    for (let [cur, expression] of expressions.entries()) {
        if (expression.type !== 'AssignmentExpression')
            continue;
        const badIndex = getValueExpr(expression.left);
        if (badIndex == null)
            continue;
        let name;
            switch (expression.left.type) {
                case 'Identifier':
                    name = expression.left.name;
                    break;
                default:
                    name = expression.left.object.name;
                    break;
            }
        array[badIndex] = expression.right;
        var cb_replaceArrayExpSpecific = function(node, scope) {
            return cb_replaceArrayExp(node, array, name);
        };
        for (let i = cur; i < expressions.length; i++) {
            traverse(expressions[i], cb_replaceArrayExpSpecific);
        }
        console.log(escodegen.generate(node));
    }
    return node;
}

function applyToNodePointer(source, destination) {
    // Clear (remove) all existing keys from the destination object
    for (const key in destination) {
        if (destination.hasOwnProperty(key)) {
            delete destination[key];
        }
    }

    // Copy keys from the source object to the destination object
    for (const key in source) {
        if (source.hasOwnProperty(key)) {
            destination[key] = source[key];
        }
    }
}
  

function cb_replaceArrayExp(node, array, name) {
    if (node.type === 'MemberExpression' && node.object.name === name && node.parent.type !== 'AssignmentExpression') {
        // console.log(escodegen.generate(node))
        // console.error(escodegen.generate(node.parent))
        const value = evalBinaryExpression(node.property);
        if (value == null)
            return node;
        let correctNode = array[value]
        if (typeof(correctNode) === 'undefined')
            return node;
        const oldParent = node.parent;
        applyToNodePointer(correctNode, node);
        // correctNode = Object.assign({}, correctNode);
        node.parent = oldParent;
        return node;
    }
    return node;
}

module.exports = { translateExpression }
