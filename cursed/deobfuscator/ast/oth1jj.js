const { getValueArg, UnaryExpressionToValue, valueToNode } = require('../ast_utils');
const { bbystealsurheartwithlovebrunxkd$2kwqqf } = require('../vars/vars');

// oth1jj is function which is often redefined in different scopes
// so i use the "array" method as stack to simulate currently defined oth1jj
var bbystealsurheartwithlovebrunxkd$oth1jj = [];

function astDef_oth1jj(node, type, scope) {
    let res = 0;
    switch (type) {
        case 0: // value
            res = getValueArg(node);
            if (res == null)
                return node;
            break;
        case 1: // function callee
            const rawArg = node.arguments[0];
            res = getValueArg(rawArg);
            if (res == null)
                return node;
            break;
    }
    // scope -1 because the scope (in this ast parser) begins when the var is declared, not inside the function
    bbystealsurheartwithlovebrunxkd$oth1jj.unshift({'scope': scope - 1, 'func': function(val) {
        return bbystealsurheartwithlovebrunxkd$2kwqqf[val + res];
    }});
}

function ast_oth1jj(node) {
    const rawArg = node.arguments[0];
    let nbRes = 0;
    switch (rawArg.type) {
        case 'Literal':
            nbRes = rawArg.value;
            break;
        case 'UnaryExpression':
            nbRes = UnaryExpressionToValue(rawArg)
            break;
        default:
            // console.log(node.arguments[0]);
            return node;
    }
    let res = bbystealsurheartwithlovebrunxkd$oth1jj[0].func(nbRes);
    return valueToNode(node, res);
}

module.exports = { ast_oth1jj, astDef_oth1jj, bbystealsurheartwithlovebrunxkd$oth1jj }