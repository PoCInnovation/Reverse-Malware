// The current scope is always scope[0]
// scope [{'name' : 'content', 'othername': 'othercontent'}]

const ScopeType = {
    None: 0,
    Function: 1,
    Block: 2
}

const ast_typeScopeFunction = [
    "FunctionDeclaration",
    "FunctionExpression",
    "MemberExpression",
    "ArrowFunctionExpression"
];

const ast_typeScopeBlock = [
    "BlockStatement",
    "CatchClause",
    "ForInStatement",
    "ForOfStatement",
    "ForStatement",
    "SwitchStatement",
    "TryStatement"
];

class Scope {
    constructor() {
        this.depth = 0;
        // [block, var]
        this.scope = [[{}, {}]];
        this.curVarScope = [this.scope[0][1]];
    }

    getElementFromScope(name) {
        for (let i = 0; i < this.scope.length; i++) {
            if (name in this.scope[i][0]) // block
                return this.scope[i][0][name];
            if (name in this.scope[i][1]) // var
                return this.scope[i][1][name];
        }
        return null;
    }

    isVar(node) {
        return node.type === 'FunctionDeclaration' || (node.type === 'VariableDeclaration' && node.kind === 'var');
    }

    setElementInScope(name, content, node) {
        if (this.isVar(node)) {
            this.curVarScope[0][name] = content;
        } else {
            this.scope[0][0][name] = content;
        }
    }

    inc(type) {
        this.depth++;
        this.scope.unshift([{}, {}]);
        switch (type) {
            case ScopeType.Function:
                this.curVarScope.unshift(this.scope[0][1]);
                break;
        }
    }

    dec(type) {
        if (this.depth <= 0)
            return;

        this.depth--;
        this.scope.shift()
        switch (type) {
            case ScopeType.Function:
                this.curVarScope.shift()
                break;
        }
    }

    getCurScope() {
        return this.depth;
    }

    // var is only function scoped, blocked scope is skipped
    isNodeBlock(node) {
        if (ast_typeScopeBlock.includes(node.type)) {
            return ScopeType.Block;
        } else if (ast_typeScopeFunction.includes(node.type)) {
            return ScopeType.Function;
        }
        return ScopeType.None;
    }
};

module.exports = { Scope };
